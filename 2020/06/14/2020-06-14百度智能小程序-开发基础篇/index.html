<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="robots" content="index, follow"><title>百度智能小程序-开发基础篇 • YANG-meng-97</title><meta name="description" content="百度智能小程序-开发基础篇 - YANG-meng-97"><link rel="icon" href="/favicon.svg"><link rel="stylesheet" href="https://unpkg.com/nanoreset@3.0.1/nanoreset.min.css"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="YANG-meng-97"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="YANG-meng-97" type="application/atom+xml">
</head><body><div class="wrap" id="barba-wrapper"><header><h1 class="branding"><a href="/" title="YANG-meng-97"><img class="logo-image" src="/logo.svg" alt="logo"></a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link no-barba" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="https://github.com/YANG-meng-97" target="_blank">ABOUT</a></li><li class="nav-list-item"></ul></header><div class="barba-container"><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">百度智能小程序-开发基础篇</h1><div class="post-info"><a></a>2020-06-14</div><div class="post-content"><!--toc-->

<h2><span id="da-kai-xiao-cheng-xu">打开小程序</span></h2><p><strong>1.打开小程序原理</strong></p>
<p>URL Scheme</p>
<p>App内部注册协议后，当用户在浏览器或其他App内点击相应的scheme链接，就能够调起App并打开App内的相关页面。</p>
<p><img src="/2020/06/14/2020-06-14%E7%99%BE%E5%BA%A6%E6%99%BA%E8%83%BD%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E7%AF%87/openapp.jpg" alt="openapp"></p>
<ul>
<li><p>Scheme：</p>
<ul>
<li>baiduboxapp：scheme协议。使用百度App处理这个url，使用百度App打开小程序时，这部分保持不变；</li>
</ul>
</li>
<li><p>Source：</p>
<ul>
<li><p>swan：小程序标识。通知百度App调起小程序框架，保持不变；</p>
</li>
<li><p>appKey：想要打开的小程序appKey。</p>
</li>
<li><p>page：小程序打开的页面路径，页面路径可以在小程序代码app.json文件的pages属性中提取；</p>
</li>
<li><p>query：小程序页面路径参数。</p>
</li>
</ul>
</li>
</ul>
<p>调起机制：</p>
<img src="/2020/06/14/2020-06-14%E7%99%BE%E5%BA%A6%E6%99%BA%E8%83%BD%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E7%AF%87/openappmethod.jpg" alt="openappmethod" style="zoom:50%;">

<p><strong>2.scheme生成工具</strong></p>
<p>开发者在商业投放、上线前验证等场景下可能需要获取小程序调起协议（scheme)，这时可以通过调起协议生成工具快速生成小程序scheme和二维码。</p>
<p><img src="/2020/06/14/2020-06-14%E7%99%BE%E5%BA%A6%E6%99%BA%E8%83%BD%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E7%AF%87/createscheme.jpg" alt="createscheme"></p>
<ul>
<li>App Key：小程序appKey；</li>
<li>启动页面：打开的小程序页面路径；</li>
<li>启动参数：小程序路径的参数；</li>
<li>进入场景：场景值。</li>
</ul>
<p><strong>3.调起功能开发</strong></p>
<ul>
<li><p>H5打开小程序：提供HS通用调起SDK-swanInvoke</p>
<p>引用：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"https://b.bdstatic.com/searchbox/icms/searchbox/js/swanInvoke.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        调用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    document.getElementById(&#39;btn&#39;).addEventListener(&#39;click&#39;, function () &#123;</span><br><span class="line">        window.swanInvoke(&#123;</span><br><span class="line">            appKey: &#39;4fecoAqgCIUtzIyA4FAPgoyrc4oUc25c&#39;,</span><br><span class="line">            path: &#39;pages&#x2F;view&#x2F;view&#39;,</span><br><span class="line">            query: &#123;</span><br><span class="line">                id:1,</span><br><span class="line">                type: &#39;a&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">            failUrl: &#39;https:&#x2F;&#x2F;www.baidu.com&#39; &#x2F;&#x2F; 调起失败跳转的页面</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>小程序打开小程序：打开另一个小程序可以通过组件或API的方式</p>
<ul>
<li><p>组件：在小程序中使用组件打开另一个小程序，navigator中target=”miniProgram”；</p>
</li>
<li><p>API：在小程序中农使用API打开另一个小程序，swan.navigatorToSmartProgram；</p>
</li>
</ul>
</li>
<li><p>在web-view中打开小程序</p>
<ul>
<li>在小程序的web-view中打开另一个小程序，需要在引入jssdk后，调用swan.navigatorToSamrtProgram接口。</li>
</ul>
</li>
</ul>
<p>使用这三种能力开发调起功能，只需要配置必需的小程序参数，不需要开发者拼接scheme。</p>
<p><strong>如何判断H5页面是否在小程序web-view打开？</strong></p>
<p>H5 运行时，通过 window.navigator.userAgent 获取浏览器 userAgent。当 userAgent 字符串中包含小程序标识：‘swan/’时，则说明当前环境为小程序 web-view。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在 H5 文件中</span><br><span class="line">   let UA &#x3D; window.navigator.userAgent;</span><br><span class="line">   var regex &#x3D; &#x2F;swan\&#x2F;&#x2F;;</span><br><span class="line">   console.log( regex.test(UA) );&#x2F;&#x2F; 若为true，则是在小程序的web-view中打开</span><br></pre></td></tr></table></figure>

<p><strong>4.小程序来源统计</strong></p>
<p>如果需要统计自行开发的小程序入口，或当开发者平台不能满足统计需求时，可以使用下面的方法，在小程序中手工打点统计。</p>
<ol>
<li>开发调起功能时，配置对应的调起参数。</li>
<li>在小程序 <a href="https://smartprogram.baidu.com/docs/develop/framework/app_service_register/" target="_blank" rel="noopener">App()</a> 生命周期函数的<code>onLaunch</code>和<code>onShow</code>中取得 Scheme 中小程序的相关参数。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">App(&#123;</span><br><span class="line">    onShow: function (options) &#123;</span><br><span class="line">        swan.requrest(&#123;</span><br><span class="line">            path: options.path, &#x2F;&#x2F; 小程序路径</span><br><span class="line">            query: options.query，&#x2F;&#x2F; 小程序传入的参数</span><br><span class="line">            scene: options.scene &#x2F;&#x2F; 场景值</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>两种调起能力的配置参数，与 onShow 中获取的参数名称不完全相同，参数对应关系如下表所示。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>H5 打开小程序配置参数名</th>
<th>小程序打开小程序配置参数名</th>
<th>onShow 中获取的参数名</th>
</tr>
</thead>
<tbody><tr>
<td>小程序 appKey</td>
<td>appKey</td>
<td>app-id</td>
<td>-</td>
</tr>
<tr>
<td>小程序页面路径</td>
<td>path</td>
<td>path</td>
<td>path</td>
</tr>
<tr>
<td>小程序路径的参数</td>
<td>query</td>
<td>extra-data</td>
<td>query</td>
</tr>
<tr>
<td>入口场景值</td>
<td>-</td>
<td>-</td>
<td>scene</td>
</tr>
</tbody></table>
<h2><span id="xiao-cheng-xu-dao-hang">小程序导航</span></h2><p><strong>1.页面跳转底层原理</strong></p>
<ul>
<li>navigateTo：客户端打开新的页面容器，并推入页面栈；</li>
<li>redirectTo：客户端打开新的页面容器，页面栈栈顶信息更新；</li>
<li>navigateBack：返回上一页面，页面栈栈顶弹出；</li>
<li>switchTab：点击tab；跳转某一tab页，页面栈栈顶信息更新；</li>
<li>reLaunch：页面栈清空，传入的url重新初始化为第一个页面。</li>
</ul>
<p><strong>2.原生小程序页面</strong></p>
<ul>
<li>首次打开的页面为非二级页面（app.json pages配置的首相页面或者tabBar页面），此页面不会有返回按钮和首页图标；通过跳转下一个新的页面（客户端新开的一个容器，且不为tabBar页面），则会在顶部导航栏左侧增加一个返回按钮；</li>
<li>首次打开的页面为二级页面（非app.json pages配置的首相页面或者非tabBar页面），此页面会出现首页图标；通过导航跳转下一个新的页面（客户端新开的一个容器，且不为tabBar页面），则会在首页图标左侧增加一个返回按钮；</li>
<li>跳转多次后，当返回上一个页面，客户端会将当前页面容器关掉，将待返回到的页面容器从后台切到前台展示，这一过程客户端顶部导航栏不会有刷新操作。</li>
</ul>
<p>可以在app.json或对应的page.json增加配置navigationStyle:custom，此时客户端就会隐藏掉原生顶部导航栏，开发者可以通过标签样式进行定制化导航栏。</p>
<p><strong>3.web-view组件撑起的h5页面</strong></p>
<p>在web-view组件承载h5页面中，如果想要跳转到一个新的小程序页面，需要配合jssdk进行操作。</p>
<p>需要从h5无缝转换到小程序，首先在小程序内放置一个web-view组件来链接之前的h5页面，一行代码完成了迁移到小程序的难题。</p>
<p>h5跳转到小程序页面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;webview 组件页面javascript</span><br><span class="line">navigate(url) &#123;</span><br><span class="line">    小程序.webView.navigateTo(&#123;url: &#39;..&#x2F;webview&#x2F;webview?weburl&#x3D;&#39; + url&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小程序另外一个新的webview组件页面中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; pages&#x2F;webview&#x2F;webview.js</span><br><span class="line">Page(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">    url:&#39;&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 监听页面加载,获取H5页面传递过来的weburl</span><br><span class="line">    onLoad: function (options) &#123;</span><br><span class="line">    this.setData(&#123;</span><br><span class="line">      url: options.weburl</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>并赋值给webview.小程序中的src属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; pages&#x2F;webview&#x2F;webview.小程序</span><br><span class="line">&lt;web-view src&#x3D;&quot;&#123;&#123;url&#125;&#125;&quot;&gt;&lt;&#x2F;web-view&gt;</span><br></pre></td></tr></table></figure>

<p>webview组件的返回</p>
<ul>
<li>如果当前是在使用 webview 组件的小程序页面，webview 组件首先回退展示的前一个 h5 内容，类似浏览器的网页返回。</li>
<li>如果 web-view 组件没有内容可以返回，就触发小程序页面栈的返回效果。</li>
<li>如果是当前小程序页面栈首页，再返回，会回到上一个小程序或者非小程序 NA 页面。</li>
</ul>
<p><strong>4.小程序间跳转</strong></p>
<p><img src="/2020/06/14/2020-06-14%E7%99%BE%E5%BA%A6%E6%99%BA%E8%83%BD%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E7%AF%87/navigateapp.jpg" alt="navigateapp"></p>
<p>getCurrentPages来判断当前页面栈的深度，从而决定是否应该展示[返回/回首页]</p>
<h2><span id="shi-yong-dong-tai-ku">使用动态库</span></h2><p><strong>1.动态库介绍</strong></p>
<p>动态库是指可被添加到小程序内直接使用的功能组件。开发者可直接在小程序内使用动态库，无需重复开发，为用户提供更丰富的服务。</p>
<ul>
<li><p>引入动态库代码包：</p>
<p>在app.json中声明需要使用的动态库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;dynamicLib&quot;: &#123;</span><br><span class="line">        &#x2F;&#x2F; 定义一个别名，小程序中用这个别名引用动态库。</span><br><span class="line">        &quot;myDynamicLib&quot;: &#123;</span><br><span class="line">            &#x2F;&#x2F; 这是动态库的 &#96;dynamicLibName&#96;，是全局唯一的名字，标志着被引用的动态库</span><br><span class="line">            &quot;provider&quot;: &quot;TheUniqueNameOwnedByThisDynamicLib&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用动态库</p>
</li>
</ul>
<p>自定义组件：</p>
<p>{<br>    “usingComponents”: {<br>        // 这里的 ‘myDynamicLib’ 就是上面定义的，本小程序使用此动态库的别名。<br>        // 这里的 ‘special-list’ 是此动态库的公开的自定义组件（publicComponents）的名称。<br>        // 动态库有哪些公开的自定义组件，应从各个动态库的用户文档中得到。<br>        // 这里的 ‘my-special-list’ 也是个自己定的别名，本页面或者本组件在模板中用此别名引用这个自定义组件。<br>        “my-special-list”: “dynamicLib://myDynamicLib/special-list”<br>    }<br>}</p>
<p>使用自定义组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">    &lt;view&gt;下面这个自定义组件来自于动态库&lt;&#x2F;view&gt;</span><br><span class="line">    &lt;!-- 这里的 &#39;my-special-list&#39; 就是本页面中对于此自定义组件的别名 --&gt;</span><br><span class="line">    &lt;my-special-list &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用动态库的js接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这里的 &#39;myDynamicLib&#39; 就是上面定义的，本小程序使用此动态库的别名。</span><br><span class="line">let lib &#x3D; requireDynamicLib(&#39;myDynamicLib&#39;);</span><br><span class="line">&#x2F;&#x2F; 这里调用动态库里定义的一个叫做 getData 的方法。</span><br><span class="line">&#x2F;&#x2F; 动态库有哪些公开的方法或属性可以被调用或访问，应从各个动态库的用户文档中得到。</span><br><span class="line">lib.getData();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>动态库中页面可作为小程序的启动页面，也可以作为被跳转的页面</p>
<p>启动打开动态库页面的配置方式：</p>
<p><code>__dynamicLib__/{dynamicLibName}/{dynamicLibPath}</code></p>
<p>路由跳转的url格式：</p>
<p><code>dynamicLib://{dynamicLibName}/{dynamicLibPath}</code></p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取基础库版本号</span></span><br><span class="line"><span class="keyword">const</span> &#123;SDKVersion&#125; = swan.getSystemInfoSync();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过对比版本号，高于 3.180.3 时再调用，即将跳转的页面是动态库dynamicLibName中的pages/index/index页面</span></span><br><span class="line">swan.navigateTo(&#123;</span><br><span class="line">    url: <span class="string">'dynamicLib://dynamicLibName/pages/index/index'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>启动页面的<code>dynamicLibName</code>必须为线上动态库的名字，不能为别名；</li>
<li>路由跳转url中的<code>dynamicLibName</code>可以为线上动态库的名字，也可以是别名，优先当做别名处理；</li>
<li>使用的动态库需在小程序app.json中的<code>dynamicLib</code>字段中配置；</li>
<li>支持跳转到动态库页面的API为：swan.navigateTo、swan.reLaunch、swan.redirectTo、swan.navigateToSmartProgram。</li>
</ul>
</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a class="next" href="/2020/06/09/2020-06-09%E7%99%BE%E5%BA%A6%E6%99%BA%E8%83%BD%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E8%AE%BE%E8%AE%A1%E7%AF%87/">next</a></div><div class="copyright"><p>&copy; 2020 <a href="https://YANG-meng-97.github.io">YANG-meng-97</a><br>Powered by <a href="https://hexo.io/" rel="noreferrer" target="_blank">Hexo</a></p></div></footer></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/barba.js/1.0.0/barba.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {
    Barba.Pjax.start()
})</script></body></html>